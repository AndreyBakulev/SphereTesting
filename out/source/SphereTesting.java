/* autogenerated by Processing revision 1293 on 2023-12-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SphereTesting extends PApplet {


PeasyCam cam;
Sphere sphere;
Vector3D[][] globe;
NormalizedCube[] cubeFaces = new NormalizedCube[6];
SpherifiedCube[] sCubeFaces = new SpherifiedCube[6];
Vector3D[] direction = {new Vector3D(0,-1,0), new Vector3D(0,1,0),new Vector3D(1,0,0),new Vector3D(-1,0,0),new Vector3D(0,0,1),new Vector3D(0,0,-1)};
int normCubeDetail = 15;
int normCubeRadius = 100;
public void setup(){
    /* size commented out by preprocessor */;
    cam = new PeasyCam(this,500);
    sphere = new Sphere(0,0,0,30,30,200,globe);

    for(int i = 0; i < 6; i++){
        sCubeFaces[i] = new SpherifiedCube(normCubeDetail,direction[i],normCubeRadius);
        sCubeFaces[i].constructCube();
        // cubeFaces[i] = new NormalizedCube(normCubeDetail,direction[i],normCubeRadius);
        // cubeFaces[i].constructCube();
    }
    
}
public void draw(){
    background(0);
    for(int i = 0; i < 6; i++){
        sCubeFaces[i].drawCube();
        //cubeFaces[i].drawCube();
    }
}
class NormalizedCube{
    int resolution;
    Vector3D localUp;
    Vector3D axisA;
    Vector3D axisB;
    Vector3D[] verticesArray;
    int[] triangleArray;
    int radius;
    public NormalizedCube(int resolution, Vector3D localUp, int radius){
        this.resolution = resolution;
        this.localUp = localUp;
        axisA = new Vector3D(localUp.y, localUp.z, localUp.x);
        axisB = localUp.cross(axisA);
        this.radius = radius;
    }
    public void constructCube(){
        verticesArray = new Vector3D[resolution*resolution];
        triangleArray = new int[((resolution-1)*(resolution-1))*6];
        int triIndex = 0;
        for(double y = 0; y < resolution; y++){
            for(double x = 0; x < resolution; x++){
                int i = (int) (x+(y*resolution));
                Vector2D percentDone = new Vector2D(x/(resolution-1),y/(resolution-1));
                Vector3D pointOnUnitCube = localUp.add(axisA.scale(((percentDone.x -.5f)*2))).add(axisB.scale(((percentDone.y -.5f)*2)));
                //println(pointOnUnitCube.x + " " + pointOnUnitCube.y + " " + pointOnUnitCube.z);
                //println(percentDone);
                verticesArray[i] = pointOnUnitCube;

                if(x != resolution-1  && y != resolution-1){
                    triangleArray[triIndex] = i;
                    triangleArray[triIndex+1] = i+resolution+1;
                    triangleArray[triIndex+2] = i+resolution;
                    triangleArray[triIndex+3] = i;
                    triangleArray[triIndex+4] = i+1;
                    triangleArray[triIndex+5] = i+resolution+1;
                    triIndex+= 6;
                }
            }
        }
    }
    public void drawCube(){
        // copy mesh filters part of code into here (use beginShape and endShape)
        // for(int i = 0; i < resolution; i++){
        //     beginShape(TRIANGLES);
        //     for(int j = 0; j < resolution; j+=3){
        //         PVector p1 = verticesArray[triangleArray[j+(i*resolution)]];
        //         PVector p2 = verticesArray[triangleArray[j+(i*resolution+1)]];
        //         PVector p3 = verticesArray[triangleArray[j+(i*resolution+2)]];
        //         vertex(p1.x,p1.y,p1.z);
        //         vertex(p2.x,p2.y,p2.z);
        //         vertex(p3.x,p3.y,p3.z);
        //         println(p2.x);
        //     }
        //     endShape();
        // }

        for(int i = 0; i < triangleArray.length; i+=3){
            beginShape(TRIANGLES);
            Vector3D p1 = (verticesArray[triangleArray[i]]).normalize().scale(radius);
            Vector3D p2 = (verticesArray[triangleArray[i+1]]).normalize().scale(radius);
            Vector3D p3 = (verticesArray[triangleArray[i+2]]).normalize().scale(radius);
            vertex((float)p1.x,(float)p1.y,(float)p1.z);
            vertex((float)p2.x,(float)p2.y,(float)p2.z);
            vertex((float)p3.x,(float)p3.y,(float)p3.z);
            //println(p1.y);
            
            endShape();
        }
    }
}

/*
p1 x=0 , y= 1, z = -20
p2 x=0 , y= 1, z = -20

PROBLEMS:
percentDone rounds to int so thats fs a problem
*/
class Sphere{
float x, y, z, r;
    int w, h;
    Vector3D[][] globe;
    int[][] greyScale;
    int groundLevel = 30;
    int altitude;
    
    Sphere(float x, float y, float z, int w, int h, float r, Vector3D[][] globe) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        this.h = h;
        this.r = r;
        this.globe = globe;
    }

    public void drawSphere(){
         sphere(r);
        sphereDetail(w);
        
    }
    
}
class SpherifiedCube{
    int resolution;
    Vector3D localUp;
    Vector3D axisA;
    Vector3D axisB;
    Vector3D[] verticesArray;
    int[] triangleArray;
    int radius;
    public SpherifiedCube(int resolution, Vector3D localUp, int radius){
        this.resolution = resolution;
        this.localUp = localUp;
        axisA = new Vector3D(localUp.y, localUp.z, localUp.x);
        axisB = localUp.cross(axisA);
        this.radius = radius;
    }
    public void constructCube(){
        verticesArray = new Vector3D[resolution*resolution];
        triangleArray = new int[((resolution-1)*(resolution-1))*6];
        int triIndex = 0;
        for(double y = 0; y < resolution; y++){
            for(double x = 0; x < resolution; x++){
                int i = (int) (x+(y*resolution));
                Vector2D percentDone = new Vector2D(x/(resolution-1),y/(resolution-1));
                Vector3D p = localUp.add(axisA.scale(((percentDone.x -.5f)*2))).add(axisB.scale(((percentDone.y -.5f)*2)));
                double x2 = p.x * p.x;
                double y2 = p.y * p.y;
                double z2 = p.z * p.z;
                Vector3D newPoint = new Vector3D(0,0,0);
                newPoint.x = p.x * Math.sqrt(1 - y2 / 2 - z2 / 2 + y2 * z2 / 3);
		        newPoint.y = p.y * Math.sqrt(1 - x2 / 2 - z2 / 2 + x2 * z2 / 3);
		        newPoint.z = p.z * Math.sqrt(1 - x2 / 2 - y2 / 2 + x2 * y2 / 3);
                verticesArray[i] = newPoint;

                if(x != resolution-1  && y != resolution-1){
                    triangleArray[triIndex] = i;
                    triangleArray[triIndex+1] = i+resolution+1;
                    triangleArray[triIndex+2] = i+resolution;
                    triangleArray[triIndex+3] = i;
                    triangleArray[triIndex+4] = i+1;
                    triangleArray[triIndex+5] = i+resolution+1;
                    triIndex+= 6;
                }
            }
        }
    }
    public void drawCube(){
        // copy mesh filters part of code into here (use beginShape and endShape)
        // for(int i = 0; i < resolution; i++){
        //     beginShape(TRIANGLES);
        //     for(int j = 0; j < resolution; j+=3){
        //         PVector p1 = verticesArray[triangleArray[j+(i*resolution)]];
        //         PVector p2 = verticesArray[triangleArray[j+(i*resolution+1)]];
        //         PVector p3 = verticesArray[triangleArray[j+(i*resolution+2)]];
        //         vertex(p1.x,p1.y,p1.z);
        //         vertex(p2.x,p2.y,p2.z);
        //         vertex(p3.x,p3.y,p3.z);
        //         println(p2.x);
        //     }
        //     endShape();
        // }

        for(int i = 0; i < triangleArray.length; i+=3){
            beginShape(TRIANGLES);
            Vector3D p1 = (verticesArray[triangleArray[i]]).normalize().scale(radius);
            Vector3D p2 = (verticesArray[triangleArray[i+1]]).normalize().scale(radius);
            Vector3D p3 = (verticesArray[triangleArray[i+2]]).normalize().scale(radius);
            vertex((float)p1.x,(float)p1.y,(float)p1.z);
            vertex((float)p2.x,(float)p2.y,(float)p2.z);
            vertex((float)p3.x,(float)p3.y,(float)p3.z);
            //println(p1.y);
            
            endShape();
        }
    }
}

/*
p1 x=0 , y= 1, z = -20
p2 x=0 , y= 1, z = -20

PROBLEMS:
percentDone rounds to int so thats fs a problem
*/
class Vector2D{
  public double x;
  public double y;

  public Vector2D(double x, double y){
    this.x = x;
    this.y = y;
    
  }
  public double getX(){
    return x;
  }
  public double getY(){
    return y;
  }
  public void applyForce(Vector2D force){
    x = x + force.getX();
    y = y + force.getY();
  }
  public Vector2D scale(double scalar){
    return new Vector2D(x*scalar,y*scalar);
  }
  public Vector2D add(Vector2D v){
    return new Vector2D(x+v.getX(),y+v.getY());
  }
  public Vector2D subtract(Vector2D v){
    return new Vector2D(x-v.getX(),y-v.getY());
  }
  public double dot(Vector2D v){
    return (x*v.getX() + y*v.getY());
  }
  public double length(){
    return Math.sqrt(this.dot(this));
  }
  public Vector2D normalize(){
    return this.scale(1/this.length());
  }
   public String toString(){
    return "(" + x + ", " + y + ")";
  }
}
class Vector3D{
  public double x;
  public double y;
  public double z;
  public Vector3D(double x, double y, double z){
    this.x = x;
    this.y = y;
    this.z = z;
  }
  public double getx(){
    return x;
  }
  public double gety(){
    return y;
  }
  public double getz(){
    return z;
  }
  public void applyForce(Vector3D force){
    x = x + force.getx();
    y = y + force.gety();
    z = z + force.getz();
  }
  public Vector3D scale(double scalar){
    return new Vector3D(x*scalar,y*scalar,z*scalar);
  }
  public Vector3D add(Vector3D v){
    return new Vector3D(x+v.getx(),y+v.gety(),z+v.getz());
  }
  public Vector3D subtract(Vector3D v){
    return new Vector3D(x-v.getx(),y-v.gety(),z-v.getz());
  }
  public double dot(Vector3D v){
    return (x*v.getx() + y*v.gety() + z*v.getz());
  }
  public double length(){
    return Math.sqrt(this.dot(this));
  }
  public Vector3D normalize(){
    return this.scale(1/this.length());
  }
  public Vector3D cross(Vector3D v){
    return new Vector3D((this.y*v.z) - (this.z*v.y),(this.z*v.x)- (this.x*v.z), (this.x*v.y)-(this.y*v.x));
  }

  public String toString(){
    return "(" + x + ", " + y + ", " + z + ")";
  }
  public  Vector3D Up(){ return new Vector3D(0,1,0);}
  public  Vector3D Down(){ return new Vector3D(0,-1,0);}
  public  Vector3D Left(){ return new Vector3D(-1,0,0);}
  public  Vector3D Right(){ return new Vector3D(1,0,0);}
  public  Vector3D Forward(){ return new Vector3D(0,0,-1);}
  public  Vector3D Backward(){ return new Vector3D(0,0,1);}
}


  public void settings() { size(800, 800, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SphereTesting" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
