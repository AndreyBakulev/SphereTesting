/* autogenerated by Processing revision 1293 on 2023-12-13 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import peasy.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class SphereTesting extends PApplet {


PeasyCam cam;
Sphere sphere;
Vector3D[][] globe;
NormalizedCube[] cubeFaces = new NormalizedCube[6];
SpherifiedCube[] sCubeFaces = new SpherifiedCube[6];
Icosahedron ico = new Icosahedron(1,100);
Vector3D[] direction = {new Vector3D(0,-1,0), new Vector3D(0,1,0),new Vector3D(1,0,0),new Vector3D(-1,0,0),new Vector3D(0,0,1),new Vector3D(0,0,-1)};
int normCubeDetail = 15;
int normCubeRadius = 100;
public void setup(){
    /* size commented out by preprocessor */;
    cam = new PeasyCam(this,500);
    sphere = new Sphere(0,0,0,30,30,200,globe);
    ico.createMesh();
    for(int i = 0; i < 6; i++){
        sCubeFaces[i] = new SpherifiedCube(normCubeDetail,direction[i],normCubeRadius);
        sCubeFaces[i].constructCube();
        cubeFaces[i] = new NormalizedCube(normCubeDetail,direction[i],normCubeRadius);
        cubeFaces[i].constructCube();
    }
    
}
public void draw(){
    background(0);
    ico.draw();
    for(int i = 0; i < 6; i++){
        //sCubeFaces[i].drawCube();
        //cubeFaces[i].drawCube();
    }
}
class Icosahedron{
    int resolution;
    Vector3D localUp;
    Vector3D axisA;
    Vector3D axisB;
    Vector3D[] verticesArray;
    int[] triangleArray;
    int radius;
    int recursionAmt;
    ArrayList<TriangleIndices> faces;
    ArrayList<TriangleIndices> faces2;
    double t = (1.0f + Math.sqrt(5.0f))/2.0f;
    public Icosahedron(int recursionAmt, int radius){
        this.recursionAmt = recursionAmt;
        this.radius = radius;
    }
    public void createMesh(){
        //setting 12 verticies
        verticesArray = new Vector3D[12];
        verticesArray[0] = new Vector3D(-1,  t,  0);
        verticesArray[1] = new Vector3D( 1,  t,  0);
        verticesArray[2] = new Vector3D(-1, -t,  0);
        verticesArray[3] = new Vector3D( 1, -t,  0);

        verticesArray[4] =  new Vector3D( 0, -1,  t);
        verticesArray[5] = new Vector3D( 0,  1,  t);
        verticesArray[6] = new Vector3D( 0, -1, -t);
        verticesArray[7] = new Vector3D( 0,  1, -t);

        verticesArray[8] = new Vector3D( t,  0, -1);
        verticesArray[9] = new Vector3D( t,  0,  1);
        verticesArray[10] = new Vector3D(-t,  0, -1);
        verticesArray[11] = new Vector3D(-t,  0,  1);
        //setting the 20 faces
        faces = new ArrayList<TriangleIndices>();
        //first 5 surrounding p1
        faces.add(new TriangleIndices(0, 11, 5));
        faces.add(new TriangleIndices(0, 5, 1));
        faces.add(new TriangleIndices(0, 1, 7));
        faces.add(new TriangleIndices(0, 7, 10));
        faces.add(new TriangleIndices(0, 10, 11));

        // 5 adjacent faces
        faces.add(new TriangleIndices(1, 5, 9));
        faces.add(new TriangleIndices(5, 11, 4));
        faces.add(new TriangleIndices(11, 10, 2));
        faces.add(new TriangleIndices(10, 7, 6));
        faces.add(new TriangleIndices(7, 1, 8));

        // 5 faces around point 3
        faces.add(new TriangleIndices(3, 9, 4));
        faces.add(new TriangleIndices(3, 4, 2));
        faces.add(new TriangleIndices(3, 2, 6));
        faces.add(new TriangleIndices(3, 6, 8));
        faces.add(new TriangleIndices(3, 8, 9));

        // 5 adjacent faces
        faces.add(new TriangleIndices(4, 9, 5));
        faces.add(new TriangleIndices(2, 4, 11));
        faces.add(new TriangleIndices(6, 2, 10));
        faces.add(new TriangleIndices(8, 6, 7));
        faces.add(new TriangleIndices(9, 8, 1));

        //bisecting triangles
        // for(int i = 0; i < recursionAmt; i++){
        //     faces2 = new ArrayList<TriangleIndices>();
        //     for(TriangleIndices tri : faces){
        //         //replace the triangles for 4
        //         //get the middle points of each triangle (a,b,c)
        //         int a = tri.getV1().getMiddlePoint(tri.getV2());
        //         int b = tri.getV2().getMiddlePoint(tri.getV3());
        //         int c = tri.getV3().getMiddlePoint(tri.getV1());
        //         faces2.add(new TriangleIndices(tri.getV1(),a,c));
        //         faces2.add(new TriangleIndices(tri.getV2(),b,a));
        //         faces2.add(new TriangleIndices(tri.getV3(),c,b));
        //         faces2.add(new TriangleIndices(a,b,c));

        //     }
        //     faces = faces2;
        // }
    }
    public int getMiddlePoint(int p2){
        //first check if you already have it
        //if not, get it ((vector1.add(vector2).scale(.5))
        //how do I add it to the verticeArray list?
        return 0;
    }
    public void draw(){
        for(int i = 0; i < faces.size(); i++){
            beginShape(TRIANGLES);
            //this SHOULD iterate thru each item in faces and therefore get the triangles and then draw them
            Vector3D p1 = verticesArray[faces.get(i).getV1()].scale(radius);
            Vector3D p2 = verticesArray[faces.get(i).getV2()].scale(radius);
            Vector3D p3 = verticesArray[faces.get(i).getV3()].scale(radius);
            vertex((float)p1.x,(float)p1.y,(float)p1.z);
            vertex((float)p2.x,(float)p2.y,(float)p2.z);
            vertex((float)p3.x,(float)p3.y,(float)p3.z);
            
            endShape();
        }
    }



}
/* Figure out the math for the amt of triangles every time the triangle is broken into 3 (3,6,15,45)

TRIANGLE STUFF:
the formula of total vertices is (n^2 +2)/2 where n is the amt of vertices on the bottom (two vertice) side
how to find amt of triangles on bottom? pattern: 2,3,5,9, (if u subtract initial val 2 it becomes 0,1,3,7 find an equation that follows that)
*/
class NormalizedCube{
    int resolution;
    Vector3D localUp;
    Vector3D axisA;
    Vector3D axisB;
    Vector3D[] verticesArray;
    int[] triangleArray;
    int radius;
    public NormalizedCube(int resolution, Vector3D localUp, int radius){
        this.resolution = resolution;
        this.localUp = localUp;
        axisA = new Vector3D(localUp.y, localUp.z, localUp.x);
        axisB = localUp.cross(axisA);
        this.radius = radius;
    }
    public void constructCube(){
        verticesArray = new Vector3D[resolution*resolution];
        triangleArray = new int[((resolution-1)*(resolution-1))*6];
        int triIndex = 0;
        for(double y = 0; y < resolution; y++){
            for(double x = 0; x < resolution; x++){
                int i = (int) (x+(y*resolution));
                Vector2D percentDone = new Vector2D(x/(resolution-1),y/(resolution-1));
                Vector3D pointOnUnitCube = localUp.add(axisA.scale(((percentDone.x -.5f)*2))).add(axisB.scale(((percentDone.y -.5f)*2)));
                //println(pointOnUnitCube.x + " " + pointOnUnitCube.y + " " + pointOnUnitCube.z);
                //println(percentDone);
                verticesArray[i] = pointOnUnitCube;

                if(x != resolution-1  && y != resolution-1){
                    triangleArray[triIndex] = i;
                    triangleArray[triIndex+1] = i+resolution+1;
                    triangleArray[triIndex+2] = i+resolution;
                    triangleArray[triIndex+3] = i;
                    triangleArray[triIndex+4] = i+1;
                    triangleArray[triIndex+5] = i+resolution+1;
                    triIndex+= 6;
                }
            }
        }
    }
    public void drawCube(){
        for(int i = 0; i < triangleArray.length; i+=3){
            beginShape(TRIANGLES);
            Vector3D p1 = (verticesArray[triangleArray[i]]).normalize().scale(radius);
            Vector3D p2 = (verticesArray[triangleArray[i+1]]).normalize().scale(radius);
            Vector3D p3 = (verticesArray[triangleArray[i+2]]).normalize().scale(radius);
            vertex((float)p1.x,(float)p1.y,(float)p1.z);
            vertex((float)p2.x,(float)p2.y,(float)p2.z);
            vertex((float)p3.x,(float)p3.y,(float)p3.z);
            //println(p1.y);
            
            endShape();
        }
    }
}

/*
p1 x=0 , y= 1, z = -20
p2 x=0 , y= 1, z = -20

PROBLEMS:
percentDone rounds to int so thats fs a problem
*/
class Sphere{
float x, y, z, r;
    int w, h;
    Vector3D[][] globe;
    int[][] greyScale;
    int groundLevel = 30;
    int altitude;
    
    Sphere(float x, float y, float z, int w, int h, float r, Vector3D[][] globe) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        this.h = h;
        this.r = r;
        this.globe = globe;
    }

    public void drawSphere(){
         sphere(r);
        sphereDetail(w);
        
    }
    
}
class SpherifiedCube{
    int resolution;
    Vector3D localUp;
    Vector3D axisA;
    Vector3D axisB;
    Vector3D[] verticesArray;
    int[] triangleArray;
    int radius;
    public SpherifiedCube(int resolution, Vector3D localUp, int radius){
        this.resolution = resolution;
        this.localUp = localUp;
        axisA = new Vector3D(localUp.y, localUp.z, localUp.x);
        axisB = localUp.cross(axisA);
        this.radius = radius;
    }
    public void constructCube(){
        verticesArray = new Vector3D[resolution*resolution];
        triangleArray = new int[((resolution-1)*(resolution-1))*6];
        int triIndex = 0;
        for(double y = 0; y < resolution; y++){
            for(double x = 0; x < resolution; x++){
                int i = (int) (x+(y*resolution));
                Vector2D percentDone = new Vector2D(x/(resolution-1),y/(resolution-1));
                Vector3D p = localUp.add(axisA.scale(((percentDone.x -.5f)*2))).add(axisB.scale(((percentDone.y -.5f)*2)));
                double x2 = p.x * p.x;
                double y2 = p.y * p.y;
                double z2 = p.z * p.z;
                Vector3D newPoint = new Vector3D(0,0,0);
                newPoint.x = p.x * Math.sqrt(1 - y2 / 2 - z2 / 2 + y2 * z2 / 3);
		        newPoint.y = p.y * Math.sqrt(1 - x2 / 2 - z2 / 2 + x2 * z2 / 3);
		        newPoint.z = p.z * Math.sqrt(1 - x2 / 2 - y2 / 2 + x2 * y2 / 3);
                verticesArray[i] = newPoint;

                if(x != resolution-1  && y != resolution-1){
                    triangleArray[triIndex] = i;
                    triangleArray[triIndex+1] = i+resolution+1;
                    triangleArray[triIndex+2] = i+resolution;
                    triangleArray[triIndex+3] = i;
                    triangleArray[triIndex+4] = i+1;
                    triangleArray[triIndex+5] = i+resolution+1;
                    triIndex+= 6;
                }
            }
        }
    }
    public void drawCube(){
        for(int i = 0; i < triangleArray.length; i+=3){
            beginShape(TRIANGLES);
            Vector3D p1 = (verticesArray[triangleArray[i]]).normalize().scale(radius);
            Vector3D p2 = (verticesArray[triangleArray[i+1]]).normalize().scale(radius);
            Vector3D p3 = (verticesArray[triangleArray[i+2]]).normalize().scale(radius);
            vertex((float)p1.x,(float)p1.y,(float)p1.z);
            vertex((float)p2.x,(float)p2.y,(float)p2.z);
            vertex((float)p3.x,(float)p3.y,(float)p3.z);
            //println(p1.y);
            
            endShape();
        }
    }
}

/*
p1 x=0 , y= 1, z = -20
p2 x=0 , y= 1, z = -20

PROBLEMS:
percentDone rounds to int so thats fs a problem
*/
class TriangleIndices{
    public int v1,v2,v3;
    public TriangleIndices(int v1, int v2, int v3){
        this.v1 = v1;
        this.v2 = v2;
        this.v3 = v3;
    }
    public int getV1(){
        return v1;
    }
    public int getV2(){
        return v2;
    }
    public int getV3(){
        return v3;
    }
}
class Vector2D{
  public double x;
  public double y;

  public Vector2D(double x, double y){
    this.x = x;
    this.y = y;
    
  }
  public double getX(){
    return x;
  }
  public double getY(){
    return y;
  }
  public void applyForce(Vector2D force){
    x = x + force.getX();
    y = y + force.getY();
  }
  public Vector2D scale(double scalar){
    return new Vector2D(x*scalar,y*scalar);
  }
  public Vector2D add(Vector2D v){
    return new Vector2D(x+v.getX(),y+v.getY());
  }
  public Vector2D subtract(Vector2D v){
    return new Vector2D(x-v.getX(),y-v.getY());
  }
  public double dot(Vector2D v){
    return (x*v.getX() + y*v.getY());
  }
  public double length(){
    return Math.sqrt(this.dot(this));
  }
  public Vector2D normalize(){
    return this.scale(1/this.length());
  }
   public String toString(){
    return "(" + x + ", " + y + ")";
  }
}
class Vector3D{
  public double x;
  public double y;
  public double z;
  public Vector3D(double x, double y, double z){
    this.x = x;
    this.y = y;
    this.z = z;
  }
  public double getx(){
    return x;
  }
  public double gety(){
    return y;
  }
  public double getz(){
    return z;
  }
  public void applyForce(Vector3D force){
    x = x + force.getx();
    y = y + force.gety();
    z = z + force.getz();
  }
  public Vector3D scale(double scalar){
    return new Vector3D(x*scalar,y*scalar,z*scalar);
  }
  public Vector3D add(Vector3D v){
    return new Vector3D(x+v.getx(),y+v.gety(),z+v.getz());
  }
  public Vector3D subtract(Vector3D v){
    return new Vector3D(x-v.getx(),y-v.gety(),z-v.getz());
  }
  public double dot(Vector3D v){
    return (x*v.getx() + y*v.gety() + z*v.getz());
  }
  public double length(){
    return Math.sqrt(this.dot(this));
  }
  public Vector3D normalize(){
    return this.scale(1/this.length());
  }
  public Vector3D cross(Vector3D v){
    return new Vector3D((this.y*v.z) - (this.z*v.y),(this.z*v.x)- (this.x*v.z), (this.x*v.y)-(this.y*v.x));
  }

  public String toString(){
    return "(" + x + ", " + y + ", " + z + ")";
  }
  public  Vector3D Up(){ return new Vector3D(0,1,0);}
  public  Vector3D Down(){ return new Vector3D(0,-1,0);}
  public  Vector3D Left(){ return new Vector3D(-1,0,0);}
  public  Vector3D Right(){ return new Vector3D(1,0,0);}
  public  Vector3D Forward(){ return new Vector3D(0,0,-1);}
  public  Vector3D Backward(){ return new Vector3D(0,0,1);}
}


  public void settings() { size(800, 800, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "SphereTesting" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
